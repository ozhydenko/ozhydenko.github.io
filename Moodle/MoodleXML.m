(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["MoodleXML`"];


Unprotect[ParseMoodleXML,GenerateMoodleXML,GenerateEssayQuestion,GenerateTrueQuestion,GenerateFalseQuestion,GenerateMultiChoiceQuestion,GenerateNumericalQuestion,GenerateShortQuestion,GenerateRandomValue,GenerateCalculatedQuestion];
Unprotect[GenerateMultiChoiceList,GenerateSingleChoiceList,GenerateParametrizedQuestion,GenerateParametrizedNumericalList,AddCategoriesToQuestions,RemoveCategoriesFromQuestions];
Unprotect[QuestionHintList,QuestionOptionList,QuestionAllAnswerList,QuestionAnswerList,QuestionCorrectAnswerList,QuestionIncorrectAnswerList,QuestionWrongAnswerList];
Unprotect[DefaultClozeFormat,DefaultClozeFormatQuestion,ConvertMultiChoiceToCloze];
Unprotect[ToMoodleHTMLString,PortugueseTrigReplace,GenerateSimilarExpression];


(*Structures*)
Protect[ClozeQuestionData,EssayQuestionData,FormulasQuestionData,TrueFalseQuestionData,NumericalQuestionData,ShortQuestionData,CalculatedQuestionData,CalculatedSimpleQuestionData,MultipleChoiceQuestionData];
Protect[MoodleCategoryData,MoodleDescriptionData,QuestionOption,QuestionAnswer,QuestionUnits,QuestionDataset,FileData,QuestionAnswers];
(*Question options*)
Protect[hidden,defaultgrade,penalty,responseformat,responserequired,responsefieldlines,attachments,attachmentsrequired,single,shuffleanswers,answernumbering,unitgradingtype,unitpenalty,showunits,unitsleft,usecase];
(*GenerateMultiChoiceList options*)
Protect[answersnum,mincorrectnum,minwrongnum];
(*answernumbering options*)
Protect[Numbering,Lowercase,Uppercase,Roman,Latin];
(*calculated answer special functions*)
Protect[pow,abs,exp];


Begin["`Private`"];


(*Basic structures*)
QuestionOption::usage="QuestionOption[name,value] is a structure for the option for a specific question.";
QuestionAnswer::usage="QuestionAnswer[fraction,options] is a structure for an answer for a specific question.";
QuestionUnits::usage="QuestionUnits[list of rules unit\[Rule]multiplier] is a structure for the list of units for the numerical questions.";
QuestionDataset::usage="QuestionDataset[list of variable data lists] is a structure for the data for the variables of the calculated questions.";
QuestionAnswers::usage="QuestionAnswers[list of rules] is a structure for answers in FormulasQuestionData.";
FileData::usage="FileData[file name, base64 data] is a structure for the file data. This structure appears if the file data is attached in XML outside the HTML data context.";


(*Question structures*)
ClozeQuestionData::usage="ClozeQuestionData[options] is a structure for the questions in CLOZE format: the question is specified in 'questiontext' option.";
TrueFalseQuestionData::usage="TrueFalseQuestionData[options] is a structure for the true-false questions.";
EssayQuestionData::usage="EssayQuestionData[options] is a structure for the essay questions.";
FormulasQuestionData::usage="FormulasQuestionData[?] is under development.";
NumericalQuestionData::usage="NumericalQuestionData[options,answers,units] is a structure for the numerical questions.";
ShortQuestionData::usage="ShortQuestionData[options,answers] is a structure for the short-answer questions.";
CalculatedQuestionData::usage="CalculatedQuestionData[options,answers,units,dataset] is a structure for the calculated questions.";
CalculatedSimpleQuestionData::usage="CalculatedSimpleQuestionData[options,answers,units,dataset] is a structure for the calculated questions (simple).";
MultipleChoiceQuestionData::usage="MultipleChoiceQuestionData[options,answers] is a structure for the multiple choice questions.";
MoodleDescriptionData::usage="MoodleDescriptionData[options] is a structure for the description in Moodle.";
MoodleCategoryData::usage="MoodleCategoryData[options] is a structure to specify categories in the Moodle question list.";
(*Category is a type of question in Moodle.*)


QuestionHintList[head_[L_List]]:=Cases[L,QuestionOption["hint",s_String]->s];
QuestionHintList::usage="QuestionHintList returns list of hints for a question.";
QuestionOptionList[head_[L_List]]:=Cases[L,QuestionOption[name_String/;name!="hint",val_]->Rule[name,val]];
QuestionOptionList::usage="QuestionOptionList returns list of options for a question as list of rules.";
QuestionAllAnswerList[head_[L_List]]:=Cases[L,QuestionAnswer[val_,options:{__Rule}]:>Replace["text",options]];
QuestionAllAnswerList::usage="QuestionAllAnswerList returns list of all answers for the question.";
QuestionAnswerList[head_[L_List],Selector_Function]:=Cases[L,QuestionAnswer[val_/;Selector[val],options:{__Rule}]:>Replace["text",options]];
QuestionAnswerList::usage="QuestionAllAnswerList[question,selector] returns list of all answers for the question for which selector of the fraction returns true.";
QuestionCorrectAnswerList[data_MultipleChoiceQuestionData]:=QuestionAnswerList[data,#>0&];
QuestionCorrectAnswerList::usage="QuestionCorrectAnswerList returns list of all correct answers for the question.";
QuestionIncorrectAnswerList[data_MultipleChoiceQuestionData]:=QuestionAnswerList[data,#<=0&];
QuestionIncorrectAnswerList::usage="QuestionIncorrectAnswerList returns list of all incorrect answers for the question.";
QuestionWrongAnswerList[data_MultipleChoiceQuestionData]:=QuestionAnswerList[data,#<0&];
QuestionWrongAnswerList::usage="QuestionWrongAnswerList returns list of all incorrect answers for the question.";


AddCategoriesToQuestions[L_List,categories:{__String}]:=Join[Map[MoodleCategoryData[{QuestionOption["category",#]}]&,categories],L];
AddCategoriesToQuestions[L_List,category_String]:=AddCategoriesToQuestions[L,{category}];
AddCategoriesToQuestions[L_List,category_String,info_String:"",id_:Null]:=Prepend[L,MoodleCategoryData[{QuestionOption["category",category],QuestionOption["info",info],QuestionOption["idnumber",id]}]];
AddCategoriesToQuestions::usage="AddCategoriesToQuestions[list of questions, list of categorie strings] adds all the categories to the list of questions."
RemoveCategoriesFromQuestions[L_List]:=DeleteCases[L,MoodleCategoryData[__]];
RemoveCategoriesFromQuestions::usage="RemoveCategoriesFromQuestions[list of questions] removes all the categories from the list of questions.";


(*Expression is the real number*)
RealNumberQ[num_]:=Im[num]===0;
(*String converter to store numbers in XML*)
ConvertToString[n_IntegerQ]:=n//ToString;
ConvertToString[n_?RealNumberQ]:=With[{in=IntegerPart[n]},If[n==in,in//ToString,ToString[n//N,InputForm]]];
ConvertToString[n_]:=n//ToString;
(*Calculate number of decimal cases after point*)
CalcDecimals[n_]:=0/;n==IntegerPart[n];
CalcDecimals[n_]:=StringSplit["0"<>Last[StringSplit[ToString[n//N,InputForm],"."]],"*^"]//(StringLength[#//First]-1-Min[0,#//Last//ToExpression])&;


(*Convert braces to their HTML representations for storing in cloze format*)
ClozeStringStore[s_String]:=StringReplace[s,{"{"->"&#123;","}"->"&#125;",Whitespace->" "},IgnoreCase->True];
(*Convert HTML representations for braces*)
ClozeStringRestore[s_String]:=StringReplace[s,{"&#123;"->"{","&#x7b;"->"{","&#125;"->"}","&#x7d;"->"}"},IgnoreCase->True];
(*Ignore nonstrings*)
ClozeStringRestore[e_]:=e;


(*Parse one answer option in cloze*)
ParseClozeAnswerOption[{fraction_String:"0",option_String}]:={If[StringMatchQ[fraction,NumberString],fraction//ToExpression,(*not a number!*)fraction],option};
ParseClozeAnswerOption[e_]:=Print[e//ToString];
(*Parse list of answers in cloze*)
ParseClozeAnswers[{weight_String:"1",type_String,answers_String}]:={weight//ToExpression,type,DeleteCases[Map[ ParseClozeAnswerOption[StringSplit[#,"%"]]&,StringSplit[StringReplace[answers,"="->"%100%"],"~"] ],Null]};
(*TODO:Error*)
ParseClozeAnswers[L_List]:=Print[L//ToString];
(*Parse string in cloze format*)
ParseClozeQuestion[question_String]:=Cases[Map[ClozeStringRestore,StringSplit[question,"{"~~qdata:RegularExpression["[^\{\}]+"]~~"}":>ParseClozeAnswers[StringSplit[qdata,":"]]]],s_/;StringQ[s]||ListQ[s]];


(*Convert one answer option to Cloze format*)
ClozeAnswerOptionToString[option_String]:=option;
ClozeAnswerOptionToString[{option_String}]:=option;
(*Each answer option contains a fraction and string*)
ClozeAnswerOptionToString[{fraction_Integer,option_String}]:=StringJoin["%",fraction//ToString,"%",option];
(*Misusing correction*)
ClozeAnswerOptionToString[{fraction_?NumberQ,option_String}]:=With[{intfrac=fraction//N//Re//IntegerPart},
Message[ConvertMultiChoiceToCloze::npi,fraction//ToString,intfrac//ToString];
ClozeAnswerOptionToString[{intfrac,option}]
];
ClozeAnswerOptionToString[{option_String,fraction_?NumberQ}]:=ClozeAnswerOptionToString[{fraction,option}];
(*Error*)
ClozeAnswerOptionToString[e_]:=Message[ConvertMultiChoiceToCloze::nof,e//Head//ToString];
(*Convert list of answer options to Cloze format*)
ClozeAnswersToString[{weight_Integer/;weight>0,type_String,answers_List}]:=StringJoin["{",weight//ToString,":",type,":",StringJoin[Riffle[DeleteCases[Map[ClozeAnswerOptionToString,answers],Null],"~"]],"}"];
(*Convert braces in strings*)
ClozeAnswersToString[s_String]:=s//ClozeStringStore;
(*Wrong element*)
ClozeAnswersToString[e_]:=e//ToHTMLString//ClozeStringStore;
(*Parsing a user-defined list of elements and answers*)
ToClozeQuestionFormat[L_List]:=StringJoin[DeleteCases[Map[ClozeAnswersToString,L],Null]];
(*Catching a user-defined element*)
ToClozeQuestionFormat[e_]:=e//ToString//ClozeStringStore;


DefaultClozeFormat="<p>`1`</p><ul>`2`</ul>";
DefaultClozeFormatQuestion=Function[{number,answer,fraction},
If[fraction>0
,{"<li>",{1,"MC",{{0,"?"},{100,"+"},{-100,"-"}}}," ",answer,"</li>"}
,{"<li>",{1,"MC",{{0,"?"},{-100,"+"},{100,"-"}}}," ",answer,"</li>"}
]
];
AllowedClozeOptionQ=Or[#==="",#==="penalty",#==="generalfeedback",#==="hidden"]&;
AddNumberToList=Transpose[Prepend[#//Transpose,Range[#//Length]]]&;
ConvertMultiChoiceToCloze::usage="ConvertMultiChoiceToCloze[questions,format question string,format answer function] converts all multiple choice questions to the Cloze format.";
ConvertMultiChoiceToCloze[L_List,FormatString_String:DefaultClozeFormat,FormatQuestion_Function:DefaultClozeFormatQuestion]:=Map[ConvertMultiChoiceToCloze[#,FormatString,FormatQuestion]&,L];
ConvertMultiChoiceToCloze[MultipleChoiceQuestionData[L_List],FormatString_String:DefaultClozeFormat,FormatQuestion_Function:DefaultClozeFormatQuestion]:=With[{Shuffle=If[Cases[L,QuestionOption["shuffleanswers",e_]:>e]//First,RandomSample,#&]},
ClozeQuestionData[
Append[Cases[L,QuestionOption[_?AllowedClozeOptionQ,_]]
,QuestionOption["questiontext",StringForm[FormatString//ClozeAnswersToString,Cases[L,QuestionOption["questiontext",s_String]:>s]//First//ClozeAnswersToString,Map[ToClozeQuestionFormat[FormatQuestion[Sequence@@#]]&,Cases[L,QuestionAnswer[val_,options:{__Rule}]:>{Replace["text",options],val}]//Shuffle//AddNumberToList]//StringJoin]]
]
]
]
ConvertMultiChoiceToCloze[e_,options__]:=e;
ConvertMultiChoiceToCloze::npi="Invalid Cloze fraction `1`, `2` is used.";
ConvertMultiChoiceToCloze::nof="Ignored invalid Cloze answer option `1`.";


(*Moodle special values*)
MathematicaToMoodleOptions={Numbering->"123",Uppercase->"ABCD",Lowercase->"abc",Roman->"IIII",Latin->"iii",None->"none",True->"true",False->"false"};
MoodleNumberingToMathematicaOptions=Cases[Drop[MathematicaToMoodleOptions,-2],Rule[A_,B_]:>Rule[B//ToLowerCase,A]];
(*Parsing multiple choice questions*)
AllowedAnswerFormatQ["moodle_auto_format"]:=True;
AllowedAnswerFormatQ["plain_text"]:=True;
AllowedAnswerFormatQ["html"]:=True;
AllowedAnswerFormatQ[_]:=False;
(*Options*)
ParseXMLData[XMLElement["name", {}, {XMLElement["text", {}, {val_String}]}]]:=QuestionOption["",val];(*Basic naming element*)
ParseXMLData[XMLElement["category", {}, {XMLElement["text", {}, {val_String}]}]]:=QuestionOption["category",val];(*Category name*)
ParseXMLData[XMLElement["text", {}, {XMLObject["CDATASection"][s_String]}]]:=QuestionOption["text",s];(*String*)
ParseXMLData[XMLElement["text", {}, {}]]:=QuestionOption["text",""];(*Empty string*)
(*When CDATASection is not preseved text can still be a string*)
ParseXMLData[XMLElement["text", {}, {val_String}]]:=QuestionOption["text",If[StringMatchQ[val,NumberString],val//ToExpression,val]];(*can be a number for numerical question*)
ParseXMLData[XMLElement[head_String, {}, {XMLElement["text", {}, {}]}]]:=QuestionOption[head,""];(*Unformatted empty string*)
(*TODO: write a good parser for HTML data*)
ParseXMLData[XMLElement[head_String, {"format" -> _?AllowedAnswerFormatQ}, data:{__XMLElement}]]:=With[{pdata=data//ParseXMLData},With[{textval=Cases[pdata,QuestionOption["text",s_]->s],ReplaceRules=Cases[pdata,FileData[file_,s_]:>Rule[file,s]]},
QuestionOption[head,If[textval=={},Message[ParseMoodleXML::textnotfound,head];"",textval//First//If[StringQ[#],StringReplace[#,ReplaceRules],#]&]]
]];
(*Simple file parser*)
ParseXMLData[XMLElement["file", r:{__Rule}, {s_String}]]:=FileData[StringJoin@@ReplaceAll[{"@@PLUGINFILE@@","path","name"},r],"data:image/png;base64,"<>s];
(*Special fields: plain_text?*)
ParseXMLData[XMLElement["varsrandom", {}, data:{__XMLElement}]]:=ParseXMLData[XMLElement["varsrandom", {"format" -> "plain_text"}, data]];
ParseXMLData[XMLElement["varsglobal", {}, data:{__XMLElement}]]:=ParseXMLData[XMLElement["varsglobal", {"format" -> "plain_text"}, data]];
(*Answers*)
ParseXMLData[XMLElement["answer", {"fraction" -> frac_String, "format" -> _?AllowedAnswerFormatQ}, optlist:{__XMLElement}]]:=QuestionAnswer[If[StringMatchQ[frac,NumberString],frac//ToExpression,Message[ParseMoodleXML::unsupportedoption,"answer fraction",frac];frac],Cases[optlist//ParseXMLData,QuestionOption[name_String,val_]->Rule[name,val]]];
(*Wrong answer format*)
ParseXMLData[XMLElement["answer", {"fraction" -> frac_String, "format" -> format_String}, optlist:{__XMLElement}]]:=Message[ParseMoodleXML::wronganswerformat,format];
(*Simple answer format?*)
ParseXMLData[XMLElement["answer", {"fraction" -> frac_String}, optlist:{__XMLElement}]]:=XMLElement["answer", {"fraction" -> frac, "format" -> "plain_text"}, optlist]//ParseXMLData;
(*Wrong answer*)
ParseXMLData[XMLElement["answer", _List, _List]]:=Message[ParseMoodleXML::wronganswer];
(*answernumbering options*)
ParseXMLData[XMLElement["answernumbering", {}, {val_String}]]:=With[{res=Replace[val//ToLowerCase,MoodleNumberingToMathematicaOptions]},QuestionOption["answernumbering",If[StringQ[res],Message[ParseMoodleXML::unsupportedoption,"answernumbering",val];val,res]]];
(*Response format*)
ParseXMLData[XMLElement["responseformat", {}, {val_String}]]:=QuestionOption["responseformat",val];
(*Parser of simple array*)
ParseXMLArray[name_String,Rule[item_String,val_String],XMLElement[name_String, {}, {XMLElement[val_String, {}, {valstr_String}], XMLElement[item_String, {}, {itemstr_String}]}]]:=Rule[itemstr,If[StringMatchQ[valstr,NumberString],valstr//ToExpression,Message[ParseMoodleXML::unsupportedoption,item,valstr];multiplier]];
ParseXMLArray[name_String,Rule[item_String,val_String],XMLElement[name_String, {}, {XMLElement[item_String, {}, {itemstr_String}], XMLElement[val_String, {}, {valstr_String}]}]]:=Rule[itemstr,If[StringMatchQ[valstr,NumberString],valstr//ToExpression,Message[ParseMoodleXML::unsupportedoption,item,valstr];multiplier]];
ParseXMLArray[name_String,Rule[item_String,val_String],XMLElement[name_String, {}, {XMLElement[val_String, __], XMLElement[item_String, __]}]]:=Message[ParseMoodleXML::wrongelement,item];
ParseXMLArray[name_String,Rule[item_String,val_String],XMLElement[name_String, {}, {__XMLElement}]]:=Message[ParseMoodleXML::wrongformat,name,item,val];
ParseXMLArray[name_String,Rule[item_String,val_String],XMLElement[name_String, __]]:=Message[ParseMoodleXML::wrongelement,name];
ParseXMLArray[name_String,Rule[item_String,val_String],XMLElement[s__]]:=Message[ParseMoodleXML::wrongstructure,{s}//First//ToString];
ParseXMLArray[name_String,Rule[item_String,val_String],L:{__XMLElement}]:=DeleteCases[Map[ParseXMLArray[name,Rule[item,val],#]&,L],Null];
(*Units*)
ParseXMLData[XMLElement["units", {}, L:{__XMLElement}]]:=QuestionUnits[ParseXMLArray["unit",Rule["unit_name","multiplier"],L]];
(*Parser of dataset list*)
ParseXMLList[XMLElement["dataset_items", {}, L:{__XMLElement}]]:=Rule["dataset_items",ParseXMLArray["dataset_item",Rule["value","number"],L]];
ParseXMLList[XMLElement["type", {}, {s_String}]]:=Rule["type",s];
(*Answers special fields*)
AnswersSpecialHTMLNameQ=StringQ[#]&&MemberQ[{"subqtext","feedback","correctfeedback","partiallycorrectfeedback","incorrectfeedback"},#]&;
ParseXMLList[XMLElement[name_?AnswersSpecialHTMLNameQ, R__]]:=With[{res=XMLElement[name, R]//ParseXMLData},If[Head[res]===QuestionOption,Rule@@res,Null] ];
AnswersSpecialTextNameQ=StringQ[#]&&MemberQ[{"placeholder","vars1","vars2","postunit","otherrule","subqtext"},#]&;
ParseXMLList[XMLElement[name_?AnswersSpecialTextNameQ, {}, {XMLElement["text", {}, {}]}]]:=Rule[name,""];
ParseXMLList[XMLElement[name_?AnswersSpecialTextNameQ, {}, {XMLElement["text", {}, {s_String}]}]]:=Rule[name,s];
ParseXMLList[XMLElement[name_?AnswersSpecialTextNameQ, {}, {XMLElement["text", {}, {XMLObject["CDATASection"][s_String]}]}]]:=Rule[name,s];
(*Format for usual fields*)
ParseXMLList[XMLElement[head_String, {}, {XMLElement["text", {}, {s_String}]}]]:=Rule[head,s];
ParseXMLList[XMLElement[head_String, {}, {val_String}]]:=Rule[head,If[StringMatchQ[val,NumberString],val//ToExpression,Message[ParseMoodleXML::unsupportedoption,head,val];val]];
ParseXMLList[XMLElement[s_String, L_List, x:{__XMLElement}]]:=Message[ParseMoodleXML::unknownstructure,s];
ParseXMLList[XMLElement[s__]]:=Message[ParseMoodleXML::wrongstructure,{s}//First//ToString];
ParseXMLList[name_String,XMLElement[name_String, {}, L:{__XMLElement}]]:=DeleteCases[Map[ParseXMLList,L],Null];
ParseXMLList[name_String,XMLElement[name_String, __]]:=Message[ParseMoodleXML::wrongelement,name];
ParseXMLList[name_String,XMLElement[s__]]:=Message[ParseMoodleXML::wrongstructure,{s}//First//ToString];
ParseXMLList[name_String,L:{__XMLElement}]:=DeleteCases[Map[ParseXMLList[name,#]&,L],Null];
(*Dataset defintion*)
ParseXMLData[XMLElement["dataset_definitions", {}, optlist:{__XMLElement}]]:=QuestionDataset[ParseXMLList["dataset_definition",optlist]];
(*Answers structure defintion*)
ParseXMLData[XMLElement["answers", {}, L:{__XMLElement}]]:=QuestionAnswers[DeleteCases[Map[ParseXMLList,L],Null]];
(*Null element*)
ParseXMLData[XMLElement[head_String, {}, {}]] := QuestionOption[head, Null];
(*true/false options*)
ParseXMLData[XMLElement[head_String, {}, {"true"}]]:=QuestionOption[head,True];
ParseXMLData[XMLElement[head_String, {}, {"false"}]]:=QuestionOption[head,False];
(*Apply ToExpression only to numeric options in order to avoid exploits in xml*)
ParseXMLData[XMLElement[head_String, {}, {val_String}]]:=QuestionOption[head,If[StringMatchQ[val,NumberString],val//ToExpression,Message[ParseMoodleXML::unsupportedoption,head,val];val]];
(*Error*)
ParseXMLData[XMLElement[s_String, L_List, x:{__XMLElement}]]:=Message[ParseMoodleXML::unknownstructure,s];
ParseXMLData[XMLElement[s__]]:=Message[ParseMoodleXML::wrongstructure,{s}//First//ToString];
(*Ignored structures are Null*)
ParseXMLData[XMLList:{__XMLElement}]:=DeleteCases[ParseXMLData/@XMLList,Null];
(*Parses either XMLElement or a list of XMLElement*)


(*Base parser data selector*)
ParseMoodleXMLElement[XMLElement["question", {"type" -> "category"}, questlist : {__XMLElement}]]:=MoodleCategoryData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> "description"}, questlist : {__XMLElement}]]:=MoodleDescriptionData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> "truefalse"}, questlist : {__XMLElement}]]:=TrueFalseQuestionData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> "numerical"}, questlist : {__XMLElement}]]:=NumericalQuestionData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> "shortanswer"}, questlist : {__XMLElement}]]:=ShortQuestionData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> "calculated"}, questlist : {__XMLElement}]]:=CalculatedQuestionData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> "calculatedsimple"}, questlist : {__XMLElement}]]:=CalculatedSimpleQuestionData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> "multichoice"}, questlist : {__XMLElement}]]:=MultipleChoiceQuestionData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> "formulas"}, questlist : {__XMLElement}]]:=FormulasQuestionData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> "essay"}, questlist : {__XMLElement}]]:=EssayQuestionData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> "cloze"}, questlist : {__XMLElement}]]:=ClozeQuestionData[questlist//ParseXMLData];
ParseMoodleXMLElement[XMLElement["question", {"type" -> t_String}, __]]:=Message[ParseMoodleXML::unknownquestion,t];
ParseMoodleXMLElement[XMLElement[s_String, __]] := Message[ParseMoodleXML::unknownstructure,s];
ParseMoodleXMLElement[element_] := Message[ParseMoodleXML::unknownelement, element//Head//ToString];
RemoveWhitespaces=DeleteCases[#,s_String/;StringMatchQ[s,Whitespace],\[Infinity]]&;(*Remove whitespaces when imported with "NormalizeWhitespace"->False*)
ParseMoodleXML[XMLObject["Document"][{XMLObject["Declaration"]["Version" -> "1.0", "Encoding" -> "UTF-8"]}, XMLElement["quiz", {}, L_List], IgnoreList_List]]:=DeleteCases[Map[ParseMoodleXMLElement,L//RemoveWhitespaces],Null];
ParseMoodleXML::usage="ParseMoodleXML[xml document] parses Moodle XML document and returns list of all the questions and categories.";
ParseMoodleXML::wronganswerformat="Unsupported answer format `1`.";
ParseMoodleXML::wronganswer="Unrecognized answer format.";
ParseMoodleXML::wrongformat="Ignored wrong format of the structure `1`: Could not find elements `2` and `3`.";
ParseMoodleXML::wrongelement="Ignored wrong format of the element `1`.";
ParseMoodleXML::unsupportedoption="Unsupported `1` value `2`.";
ParseMoodleXML::textnotfound="Could not find a text field for the moodle structure `1`. Empty string is used.";
ParseMoodleXML::unknownquestion="Unknwon question type `1` is encountered. This question is ignored by the current version of the parser.";
ParseMoodleXML::wrongstructure="Unrecognized Moodle structure `1`.";
ParseMoodleXML::unknownstructure="Unknown moodle structure `1` is encountered. This structure is ignored by the current version of the parser.";
ParseMoodleXML::unknownelement="Unknown element `1` is encountered when parsing Moodle XML data. This element is ignored by the current version of the parser.";


(*String option to XML format*)
ConvertDataXML[QuestionOption["",s_String]]:=XMLElement["name", {}, {XMLElement["text" ,{}, If[s=="",{},{s}] ]}];
ConvertDataXML[QuestionOption["category",s_String]]:=XMLElement["category", {}, {XMLElement["text" ,{}, If[s=="",{},{s}] ]}];
ConvertDataXML[QuestionOption["text",s_String]]:=XMLElement["text", {}, If[s=="",{},{XMLObject["CDATASection"][s]}]];
ConvertDataXML[QuestionOption["responseformat",s_String]]:=XMLElement["responseformat", {}, {s}];
ConvertDataXML[QuestionOption[head_String,""]]:=XMLElement[head, {}, {XMLElement["text", {}, {}]}];
ConvertDataXML[QuestionOption[head_String,s_String]]:=XMLElement[head, {"format" -> "html"}, {QuestionOption["text",s]//ConvertDataXML}];
ConvertDataXML[QuestionOption[head_String,s_StringForm]]:=QuestionOption[head,s//ToString]//ConvertDataXML;
(*Valued option to XML format*)
ConvertDataXML[QuestionOption[head_String/;head!="", Null]]:=XMLElement[head, {}, {}];
ConvertDataXML[QuestionOption[head_String/;head!="", val_]]:=XMLElement[head, {}, {val/.MathematicaToMoodleOptions//ConvertToString}];
(*File?*)
ConvertDataXML[FileData[name_String,_]]:=Message[GenerateMoodleXML::unexpectedfile,name];
(*Answer to XML format*)
ConvertDataXML[QuestionAnswer[frac_,options:{__Rule}]]:=XMLElement["answer", {"fraction" -> ConvertToString[frac], "format" -> "html"}, Apply[QuestionOption,options,1]//ConvertDataXML];
ConvertDataXML[QuestionAnswer[answer_String,frac_]]:=ConvertDataXML[QuestionAnswer[frac,{"text"->answer}]]; (*Old answer format*)
(*Array to XML format*)
ConvertArrayXML[name_String,Rule[ename_String,vname_String],Rule[element_,val_]]:=XMLElement[name, {}, {XMLElement[vname, {}, {val//ConvertToString}], XMLElement[ename, {}, {element//ConvertToString}]}];
ConvertDataXML[QuestionUnits[unitslist:{__Rule}]]:=XMLElement["units", {}, DeleteCases[Map[ConvertArrayXML["unit",Rule["unit_name","multiplier"],#]&,unitslist],Null]];
(*Answers special fields to XML format*)
ConvertListElementXML[Rule[name_?AnswersSpecialHTMLNameQ,s_String]]:=QuestionOption[name,s]//ConvertDataXML;
ConvertListElementXML[Rule[name_?AnswersSpecialTextNameQ,s_String]]:=XMLElement[name, {}, {XMLElement["text", {}, If[s==="",{},{XMLObject["CDATASection"][s]}] ]} ];
(*dataset to XML format*)
ConvertListElementXML[Rule["type",val_]]:=XMLElement["type", {}, {val//ConvertToString}];
ConvertListElementXML[Rule["dataset_items",unitslist:{__Rule}]]:=XMLElement["dataset_items", {}, DeleteCases[Map[ConvertArrayXML["dataset_item",Rule["value","number"],#]&,unitslist],Null]];
ConvertListElementXML[Rule[head_String,s_String]]:=XMLElement[head, {}, {XMLElement["text", {}, {s}]}];
ConvertListElementXML[Rule[head_String,val_]]:=XMLElement[head, {}, {val//ConvertToString}];
ConvertListElementXML[Rule[e_,__]]:=Message[GenerateMoodleXML::unknownelement,e//ToString];
ConvertListXML[name_String,L:{__Rule}]:=XMLElement["dataset_definition", {}, DeleteCases[Map[ConvertListElementXML,L],Null]];
ConvertListXML[name_String,_List]:=Message[GenerateMoodleXML::wronglist,name];
ConvertDataXML[QuestionDataset[L:{__List}]]:=XMLElement["dataset_definitions", {}, DeleteCases[Map[ConvertListXML["dataset_definition",#]&,L],Null] ];
ConvertDataXML[QuestionDataset[L:{__Rule}]]:=ConvertDataXML[QuestionDataset[{L}]];
ConvertDataXML[QuestionAnswers[L:{__Rule}]]:=XMLElement["answers", {}, DeleteCases[Map[ConvertListElementXML,L],Null] ];
(*List of elements*)
ConvertDataXML[L_List]:=DeleteCases[Map[ConvertDataXML,L],Null];
(*Error*)
ConvertDataXML[element_]:=Message[GenerateMoodleXML::unknownelement,element//Head//ToString];


(*Question list to XML format*)
GenerateXMLElement[MoodleCategoryData[data_List]]:=XMLElement["question", {"type" -> "category"}, data//ConvertDataXML];
GenerateXMLElement[MoodleDescriptionData[data_List]]:=XMLElement["question", {"type" -> "description"}, data//ConvertDataXML];
GenerateXMLElement[TrueFalseQuestionData[data_List]]:=XMLElement["question", {"type" -> "truefalse"}, data//ConvertDataXML];
GenerateXMLElement[NumericalQuestionData[data_List]]:=XMLElement["question", {"type" -> "numerical"}, data//ConvertDataXML];
GenerateXMLElement[ShortQuestionData[data_List]]:=XMLElement["question", {"type" -> "shortanswer"}, data//ConvertDataXML];
GenerateXMLElement[CalculatedQuestionData[data_List]]:=XMLElement["question", {"type" -> "calculated"}, data//ConvertDataXML];
GenerateXMLElement[CalculatedSimpleQuestionData[data_List]]:=XMLElement["question", {"type" -> "calculatedsimple"}, data//ConvertDataXML];
GenerateXMLElement[MultipleChoiceQuestionData[data_List]]:=XMLElement["question", {"type" -> "multichoice"}, data//ConvertDataXML];
GenerateXMLElement[FormulasQuestionData[data_List]]:=XMLElement["question", {"type" -> "formulas"}, data//ConvertDataXML];
GenerateXMLElement[EssayQuestionData[data_List]]:=XMLElement["question", {"type" -> "essay"}, data//ConvertDataXML];
GenerateXMLElement[ClozeQuestionData[data_List]]:=XMLElement["question", {"type" -> "cloze"}, data//ConvertDataXML];
GenerateXMLElement[element_]:=Message[GenerateMoodleXML::unknownelement, element//Head//ToString];
GenerateMoodleXML[questionsdata_List]:=XMLObject["Document"][{XMLObject["Declaration"]["Version" -> "1.0", "Encoding" -> "UTF-8"]}, XMLElement["quiz", {}, DeleteCases[GenerateXMLElement/@questionsdata,Null]], {}];
GenerateMoodleXML[element_]:=GenerateMoodleXML[{element}];
GenerateMoodleXML::usage="GenerateMoodleXML[list of questions and categories] converts the list to the Moodle XML format.";
GenerateMoodleXML::wronglist="Wrong definition of the Moodle list element `1` has been ignored.";
GenerateMoodleXML::unknownelement="Unknown Moodle structure `1` has been ignored.";
GenerateMoodleXML::unexpectedfile="Structure of file `1` has been encountered outside the HTML context.";


(*responseformat:"editor", "editorfilepicker", "plain", "monospaced", "responsetemplate", "noinline"*)
GenerateEssayQuestion[name_String/;name!="",question_String/;question!="",graderinfo_String:"",OptionsPattern[{defaultgrade->1,penalty->0,responseformat->"noinline",responserequired->0,responsefieldlines->0,attachments->1,attachmentsrequired->1,hidden->0}]]:=EssayQuestionData[{QuestionOption["",name],QuestionOption["questiontext",question],QuestionOption["defaultgrade",OptionValue[defaultgrade]],QuestionOption["penalty",OptionValue[penalty]],QuestionOption["hidden",OptionValue[hidden]],QuestionOption["responseformat",OptionValue[responseformat]],QuestionOption["responserequired",OptionValue[responserequired]],QuestionOption["responsefieldlines",OptionValue[responsefieldlines]],QuestionOption["attachments",OptionValue[attachments]],QuestionOption["attachmentsrequired",OptionValue[attachmentsrequired]],QuestionOption["graderinfo",graderinfo]}];


ListWithoutDuplicates[L_List]:=SameQ[L,DeleteDuplicates[L]];(*DuplicateFreeQ for backward compatibility*)
(*Generating list of answers with given fractions. If number of fractions is smaller than number of answers, the last fraction repeats.*)
GenerateAnswersList[answers:{__String},fracs:{__?RealNumberQ}]:=Map[QuestionAnswer[Last[#],{"text"->First[#]}]&,{answers,Join[fracs,ConstantArray[fracs//Last,Length[answers]-Length[fracs]]]}//Transpose ]/;0<Length[fracs]<=Length[answers];
GenerateMultiChoiceQuestion[name_String/;name!="",question_String/;question!="",answers:{__String},fracs:{__?RealNumberQ},OptionsPattern[{defaultgrade->1,penalty->1,single->False,shuffleanswers->True,answernumbering->None,hidden->0}]]:=MultipleChoiceQuestionData[Join[{QuestionOption["",name],QuestionOption["questiontext",question],QuestionOption["defaultgrade",OptionValue[defaultgrade]],QuestionOption["penalty",OptionValue[penalty]],QuestionOption["single",OptionValue[single]],QuestionOption["shuffleanswers",OptionValue[shuffleanswers]],QuestionOption["answernumbering",OptionValue[answernumbering]],QuestionOption["hidden",OptionValue[hidden]],QuestionOption["shownumcorrect",Null]},GenerateAnswersList[answers,fracs]]]/;0<Length[fracs]<=Length[answers];
GenerateMultiChoiceQuestion::usage="GenerateMultiChoiceQuestion[name, question, list of answers, list of fractions] generates a multiple choice question with the list of possible answers and the corresponding fractions.";


(*Various formats of numerical answers*)
NumericalAnswerQ[{answer_?RealNumberQ,frac_?RealNumberQ,tolerance_/;tolerance>=0}]:=True;
NumericalAnswerQ[{answer_?RealNumberQ,frac_?RealNumberQ}]:=True;
NumericalAnswerQ[{answer_?RealNumberQ}]:=True;
NumericalAnswerQ[answer_?RealNumberQ]:=True;
NumericalAnswerQ[_]:=False;
(*Various formats of units*)
NumericalUnitQ[{unit_String,mul_?RealNumberQ}]:=True;
NumericalUnitQ[{unit_String}]:=True;
NumericalUnitQ[unit_String]:=True;
NumericalUnitQ[_]:=False;
(*Generating list of answers with given fractions and tolerance.*)
GenerateNumericalAnswer[{answer_,frac_:100,tolerance_:0}]:=QuestionAnswer[frac,{"text"->answer,"tolerance"->tolerance}];
GenerateNumericalAnswer[answer_]:=QuestionAnswer[100,{"text"->answer,"tolerance"->0}];
(*Generating list of units with given multipliers.*)
GenerateNumericalUnit[{unit_String,mul_:1}]:=unit->mul;
GenerateNumericalUnit[unit_String]:=unit->1;
GenerateNumericalQuestion[name_String/;name!="",question_String/;question!="",answers__?NumericalAnswerQ,OptionsPattern[{defaultgrade->1,penalty->1,unitgradingtype->0,unitpenalty->1,showunits->3,unitsleft->0,hidden->0}]]:=NumericalQuestionData[Join[{QuestionOption["",name],QuestionOption["questiontext",question],QuestionOption["defaultgrade",OptionValue[defaultgrade]],QuestionOption["penalty",OptionValue[penalty]],QuestionOption["unitgradingtype",OptionValue[unitgradingtype]],QuestionOption["unitpenalty",OptionValue[unitpenalty]],QuestionOption["showunits",OptionValue[showunits]],QuestionOption["unitsleft",OptionValue[unitsleft]],QuestionOption["hidden",OptionValue[hidden]]},Map[GenerateNumericalAnswer,{answers}]]];
GenerateNumericalQuestion[name_String/;name!="",question_String/;question!="",answers__?NumericalAnswerQ,units__?NumericalUnitQ,OptionsPattern[{defaultgrade->1,penalty->1,unitgradingtype->1,unitpenalty->1,showunits->0,unitsleft->0,hidden->0}]]:=NumericalQuestionData[Join[{QuestionOption["",name],QuestionOption["questiontext",question],QuestionOption["defaultgrade",OptionValue[defaultgrade]],QuestionOption["penalty",OptionValue[penalty]],QuestionUnits[Map[GenerateNumericalUnit,{units}]],QuestionOption["unitgradingtype",OptionValue[unitgradingtype]],QuestionOption["unitpenalty",OptionValue[unitpenalty]],QuestionOption["showunits",OptionValue[showunits]],QuestionOption["unitsleft",OptionValue[unitsleft]],QuestionOption["hidden",OptionValue[hidden]]},Map[GenerateNumericalAnswer,{answers}]]];
GenerateNumericalQuestion::usage="GenerateMultiChoiceQuestion[name, question, numerical answer, unit] generates a numerical question with a given correct answer (or answers separated by commas) and with optional unit. Use lists {answer, fraction, tolerance} to specify the fraction and numerical tolerance for each particular answer and {unit, multiplier} to introduce multipliers for additional (alternative) units.";


GenerateTrueQuestion[name_String/;name!="",question_String/;question!="",OptionsPattern[{defaultgrade->1,penalty->1,hidden->0}]]:=TrueFalseQuestionData[{QuestionOption["",name],QuestionOption["questiontext",question],QuestionOption["defaultgrade",OptionValue[defaultgrade]],QuestionOption["hidden",OptionValue[hidden]],QuestionAnswer[100,{"text"->"true"}],QuestionAnswer[0,{"text"->"false"}]}];
GenerateTrueQuestion::usage="GenerateTrueQuestion[name, question] generates a question for which correct answer is true.";
GenerateFalseQuestion[name_String/;name!="",question_String/;question!="",OptionsPattern[{defaultgrade->1,penalty->1,hidden->0}]]:=TrueFalseQuestionData[{QuestionOption["",name],QuestionOption["questiontext",question],QuestionOption["defaultgrade",OptionValue[defaultgrade]],QuestionOption["hidden",OptionValue[hidden]],QuestionAnswer[0,{"text"->"true"}],QuestionAnswer[100,{"text"->"false"}]}];
GenerateFalseQuestion::usage="GenerateFalseQuestion[name, question] generates a question for which correct answer is false.";


(*Various formats of short answers*)
ShortAnswerQ[{answer_String,frac_?RealNumberQ}]:=True;
ShortAnswerQ[{answer_String}]:=True;
ShortAnswerQ[answer_String]:=True;
ShortAnswerQ[_]:=False;
GenerateShortAnswer[{answer_,frac_:100}]:=QuestionAnswer[frac,{"text"->answer}];
GenerateShortAnswer[answer_]:=QuestionAnswer[100,{"text"->answer}];
GenerateShortQuestion[name_String/;name!="",question_String/;question!="",answers__?ShortAnswerQ,OptionsPattern[{defaultgrade->1,penalty->1,usecase->0,hidden->0}]]:=ShortQuestionData[Join[{QuestionOption["",name],QuestionOption["questiontext",question],QuestionOption["defaultgrade",OptionValue[defaultgrade]],QuestionOption["penalty",OptionValue[penalty]],QuestionOption["usecase",OptionValue[usecase]],QuestionOption["hidden",OptionValue[hidden]]},Map[GenerateShortAnswer,{answers}]]];
GenerateShortQuestion::usage="GenerateShortQuestion[name, question, answer] generates a short-answer question with a given correct answer (or answers separated by commas). Use lists {answer, fraction} to specify the fraction for each particular answer.";


GenerateRandomValue[min_?RealNumberQ,max_?RealNumberQ,tol_:1]:=N[Random[Integer,{min,max}/tol]Rationalize[tol,0],Precision[tol]]/;0<tol<Max[min//Abs,max//Abs];
GenerateRandomValue::usage="GenerateRandomValue[min,max,tolerance] generates a random value between min and max with given tolerance.";


(*Data set for simple calculated question*)
GeneratePrivateDataSet[V_Rule]:=With[{items=Last[V]},With[{num=items//Length},{"status"->"private","name"->First[V],"type"->"calculatedsimple","distribution"->"uniform","minimum"->ConvertToString[items//Min],"maximum"->ConvertToString[items//Max],"decimals"->ConvertToString[CalcDecimals/@items//Max],"itemcount"->num,"dataset_items"->Apply[Rule,{Map[ConvertToString,items],Range[num]}//Transpose,1],"number_of_items"->num}]];
GeneratePrivateDataSets[V__Rule]:=QuestionDataset[Map[GeneratePrivateDataSet,{V}]];
(*Various formats of calculated answers*)
CalculatedAnswerQ[{answer_String,frac_?RealNumberQ,tolerance_/;tolerance>0}]:=True;
CalculatedAnswerQ[{answer_String,tolerance_/;tolerance>0}]:=True;
CalculatedAnswerQ[_]:=False;
(*Variables definitions*)
VariableQ[Rule[_String,{__?RealNumberQ}]]:=True;
VariableQ[_]:=False;
(*Generating list of answers with given fractions and tolerance.*)
GenerateCalculatedAnswer[{answer_,frac_:100,tolerance_}]:=QuestionAnswer[frac,{"text"->answer,"tolerance"->tolerance,"tolerancetype"->2,"correctanswerformat"->1,"correctanswerlength"->CalcDecimals[tolerance]}];
GenerateCalculatedQuestion[name_String/;name!="",question_String/;question!="",vars__?VariableQ,answers__?CalculatedAnswerQ,OptionsPattern[{defaultgrade->1,penalty->1,unitgradingtype->0,unitpenalty->1,showunits->3,unitsleft->0,hidden->0}]]:=CalculatedSimpleQuestionData[Join[{QuestionOption["",name],QuestionOption["questiontext",question],QuestionOption["defaultgrade",OptionValue[defaultgrade]],QuestionOption["penalty",OptionValue[penalty]],QuestionOption["unitgradingtype",OptionValue[unitgradingtype]],QuestionOption["unitpenalty",OptionValue[unitpenalty]],QuestionOption["showunits",OptionValue[showunits]],QuestionOption["unitsleft",OptionValue[unitsleft]],QuestionOption["hidden",OptionValue[hidden]],GeneratePrivateDataSets[vars]},Map[GenerateCalculatedAnswer,{answers}]]];
GenerateCalculatedQuestion[name_String/;name!="",question_String/;question!="",vars__?VariableQ,answers__?CalculatedAnswerQ,units__?NumericalUnitQ,OptionsPattern[{defaultgrade->1,penalty->1,unitgradingtype->1,unitpenalty->1,showunits->0,unitsleft->0,hidden->0}]]:=CalculatedSimpleQuestionData[Join[{QuestionOption["",name],QuestionOption["questiontext",question],QuestionOption["defaultgrade",OptionValue[defaultgrade]],QuestionOption["penalty",OptionValue[penalty]],QuestionUnits[Map[GenerateNumericalUnit,{units}]],QuestionOption["unitgradingtype",OptionValue[unitgradingtype]],QuestionOption["unitpenalty",OptionValue[unitpenalty]],QuestionOption["showunits",OptionValue[showunits]],QuestionOption["unitsleft",OptionValue[unitsleft]],QuestionOption["hidden",OptionValue[hidden]],GeneratePrivateDataSets[vars]},Map[GenerateCalculatedAnswer,{answers}]]];
GenerateCalculatedQuestion::usage="GenerateCalculatedQuestion[name, question, variable(s), numerical answer(s), unit(s)] generates a calculated question with a given correct answer (or answers separated by commas), which depends on variables, and with optional unit. Variablename\[Rule]list of values specifies the variables, {answer string, fraction, tolerance} specifies the fraction and numerical tolerance for each answer, {unit name, multiplier} introduces multipliers for each unit.";


(*Structure for answers with groups is a string at the first position*)
AnswerStringQ=StringQ[{#, Null} // Flatten // First] &;
GetAnswerString[e_]:=With[{a={e} // Flatten}, First[a]/;Length[a]>0 ];
(*Groups are listed at the last position*)
GetAnswerStringGroup[s_String]:={s};
GetAnswerStringGroup[L_List]:={L//Last}//Flatten;
(*Select only those sets, where all the answers belong to different groups (GetAnswerStringGroup), and return strings (GetAnswerString)*)
DeleteAnswerSetsRepetitions[L_List]:=Cases[L, set_List/;ListWithoutDuplicates[ Flatten[Map[GetAnswerStringGroup, set], 1] ] :> Map[GetAnswerString, set]];
(*Answer with fraction*)
AnswerListWithFractionQ[{answerlist:{__?AnswerStringQ}, num_Integer /; num > 0, frac_?RealNumberQ}]:=Length[answerlist]>=num;
AnswerListWithFractionQ[__]:=False;
GenerateMultiChoiceList[name_String /; name != "", question_String /; question != "", answeropts__?AnswerListWithFractionQ]:=With[{quests=Map[Flatten[#, 1]&, Map[Subsets[#[[1]], {#[[2]]}]&, {answeropts}] // Tuples] // DeleteAnswerSetsRepetitions, fracs=Map[ConstantArray[#[[3]], #[[2]]]&, {answeropts}] // Flatten}, Map[GenerateMultiChoiceQuestion[name, question, #, fracs]&, quests]];
GenerateMultiChoiceList[name_String /; name != "", question_String /; question != "", {correctanswers:{__?AnswerStringQ},numcorrect_Integer/;numcorrect>0}, {wronganswers:{__?AnswerStringQ}, numwrong_Integer/;numwrong>0}]:=GenerateMultiChoiceList[name, question, {correctanswers, numcorrect, 100/numcorrect}, {wronganswers, numwrong, -100/numwrong}];
GenerateMultiChoiceList[name_String /; name != "", question_String /; question != "", correctanswers:{__?AnswerStringQ}, wronganswers:{__?AnswerStringQ}, OptionsPattern[{answersnum->2, mincorrectnum->1, minwrongnum->1}]]:=With[{num=OptionValue[answersnum],mw=Length[wronganswers],mc=Length[correctanswers]},
With[{cn=Max[num-mw,OptionValue[mincorrectnum]],wn=Max[num-mc,OptionValue[minwrongnum]]},
Flatten[ Map[GenerateMultiChoiceList[name,question,{correctanswers, # // First},{wronganswers, # // Last}]&, {Range[cn, num-wn], Range[num-cn, wn, -1]} // Transpose] ] /; mc>=cn>0 && mw>=wn>0 && num>=cn+wn && IntegerQ[num] && IntegerQ[cn] && IntegerQ[wn]
]
];
GenerateMultiChoiceList::usage="GenerateMultiChoiceList[name, question, {first list of answers, number to select, fraction}, {second list of answers, number to select, fraction}...] calls GenerateMultiChoiceQuestion for all possible combinations of certain number of answers from each set.\nEach answer is either a string or a list in which the first element is a string and the last element is a list of groups. Resulting questions do not contain answers of the same group.\nGenerateMultiChoiceList[name, question, list of correct answers, list of wrong answers, answersnum\[Rule]5, mincorrectnum\[Rule]1, minwrongnum\[Rule]2] generates all possible questions with 5 answers, among which at least 1 is correct and at least 2 are wrong.";
GenerateSingleChoiceList[name_String /; name != "", question_String /; question != "", correctanswers:{__?AnswerStringQ}, wronganswers:{__?AnswerStringQ}, OptionsPattern[{answersnum->2,penalty->1,answernumbering->None}]]:=
With[{wnum=OptionValue[answersnum]-1, mw=Length[wronganswers], mc=Length[correctanswers]},
Map[GenerateMultiChoiceQuestion[name, question, #, {100, 0}, penalty->OptionValue[penalty], answernumbering->OptionValue[answernumbering], single->True]& ,Map[Flatten[#, 1]&, {Subsets[correctanswers,{1}], Subsets[wronganswers,{wnum}]} // Tuples] // DeleteAnswerSetsRepetitions] /; mc>0 && mw>=wnum>0 && IntegerQ[wnum]
];
GenerateSingleChoiceList::usage="GenerateSingleChoiceList[name, question, list of correct answers, list of wrong answers, answersnum\[Rule]5] generates all possible single choice questions with 5 answers";


HoldQ=Head[#]===Hold||Head[#]===HoldForm&;
ListWithHoldQ=ListQ[#]&&Or@@Map[HoldQ,#]&;
(*Convert to string only if there is at least one held element*)
ToMoodleHTMLString[L_?ListWithHoldQ]:=L//ToHTMLString;
ToMoodleHTMLString[e_?HoldQ]:=e//ToHTMLString;
(*Otherwise recursively search such lists*)
ToMoodleHTMLString[L_List]:=Map[ToMoodleHTMLString,L];
(*Ignore other elements because they might be group names*)
ToMoodleHTMLString[S__]:=S;
ToMoodleHTMLString::usage="ToMoodleHTMLString converts lists containing at least one Hold to one single HTML string for Moodle.";


(*Final replacement of the braces*)
ToHTMLString[s_String]:=StringReplace[s,{"\\left\\{"->"\\left(","\\{"->"\\left(","\\right\\}"->"\\right)","\\}"->"\\right)","\\log "->"\\ln "}];
(*Ignore empty hold.*)
ToHTMLStringSaveList[Hold[Null]]="";
ToHTMLStringSaveList[Null]="";
(*Applying recursively to the nestes lists, which we consider as lists (with braces) in the output*)
ToHTMLStringSaveList[L_List]:="{"<>StringJoin[Riffle[Map[ToHTMLStringSaveList,L],","]]<>"}";
ToHTMLStringSaveList[e_]:=e//ToHTMLString;
(*Join all converted substrings, except for Nulls.*)
ToHTMLString[L_List]:=Riffle[DeleteCases[Map[ToHTMLStringSaveList,L],""]," "]//StringJoin;
(*Image saving in png*)
ToHTMLString[G_Graphics]:="<img src=\""<>"data:image/png;base64,"<>ExportString[G,{ "Base64","PNG"},Background->None]<>"\">";
ToHTMLString[G_Graphics3D]:="<img src=\""<>"data:image/png;base64,"<>ExportString[G,{ "Base64","PNG"},Background->None]<>"\">";
(*TeX string indication*)
ToHTMLString[s_TeXForm]:=StringJoin["\(",s//ToString//ToHTMLString,"\)"];
(*Holding expression.*)
ToHTMLString[s_HoldForm]:=s//TeXForm//ToHTMLString;
(*No TeX formatting when Hold starts or ends with a string!*)
HoldToText[Hold[Null]]:="";
HoldToText[Hold[s_String]]:=s;
HoldToText[Hold[s_TeXForm]]:=s//ToString;
HoldToText[e_Hold]:=TeXForm[HoldForm@@e]//ToString;
HoldToText[Hold[]]:="";
InsertComma=If[Or@@Apply[StringQ,#,1],#,Riffle[#,Hold[","]]]&;
RemoveFirstRest=Prepend[Map[Rest,#//Rest],#//First]&;
ToHTMLString[s_Hold/;Length[s]>1&&Or[StringQ[s//First],StringQ[s//Last]]]:=Map[HoldToText,Apply[Join,Map[InsertComma,Partition[List@@Map[Hold,s],2,1]]//RemoveFirstRest]]//StringJoin//ToHTMLString;
(*Preserve commas inside Hold.*)
HoldToHTML[Hold[Null]]:="";
HoldToHTML[e_Hold]:=TeXForm[HoldForm@@e]//ToString;
ToHTMLString[Hold[]]:="";
ToHTMLString[s_Hold]:="\("<>StringJoin[Riffle[Map[HoldToHTML,List@@Map[Hold,s]],","]]<>"\)"//ToHTMLString;
(*Convert object to the TeX format.*)
ToHTMLString[s_]:=s//TeXForm//ToHTMLString;


(*Rule to list*)
RuleRealListQ[Rule[_Symbol,{__?RealNumberQ}]]:=True;
RuleRealListQ[_]:=False;
(*Rule to number*)
RuleRealQ[Rule[_Symbol,_?RealNumberQ]]:=True;
RuleRealQ[_]:=False;
(*List of rules*)
ListRuleRealQ[{__?RuleRealQ}]:=True;
ListRuleRealQ[_]:=False;
(*Various formats of parametrized answers*)
ParametrizedAnswerQ[{answer_,frac_?RealNumberQ,tolerance_/;tolerance>0}]:=True;
ParametrizedAnswerQ[_]:=False;
(*TeX to expression*)
TeXRoExprRule={"}{"->")/(","{"->"(","}"->")","\\frac"->"","\\left"->"","\\right"->"","\\text{pow}(\\exp (1),"->"exp(","\\text{pow}\\left(\\exp (1),"->"exp(","\\text{pow}"->"pow","\\text{abs}"->"abs","\\pi"->"pi()","\\"~~f:Repeated[WordCharacter]~~Whitespace~~"^{-1}":>"a"<>f,"\\"~~f:Repeated[WordCharacter]~~Whitespace:>f,Whitespace~~")"->")",Whitespace~~"\\right)"->")",Whitespace~~","->",",Whitespace->"*"};
(*Each parameter is attributed to a list*)
RuleRealListToListRule[Rule[p_Symbol,L_List]]:=Map[p->#&,L];
GenerateParametrizedQuestion[pars__?RuleRealListQ,R__]:=GenerateParametrizedQuestion[Map[RuleRealListToListRule,{pars}]//Tuples,R];
GenerateParametrizedQuestion[pars:{__?RuleRealListQ},R__]:=GenerateParametrizedQuestion[Map[RuleRealListToListRule,pars]//Tuples,R];
(*There is only one parameter*)
GenerateParametrizedQuestion[pars_?ListRuleRealQ,R__]:=GenerateParametrizedQuestion[{pars}//Transpose,R]/;Apply[SameQ,First/@pars];
(*List of given combinations of parameters*)
GenerateParametrizedQuestion[pars:{__?ListRuleRealQ},name_String/;name!="",question_?ListWithHoldQ,R__/;ParametrizedAnswerQ[{R}//First]]:=With[{varslist=Intersection@@Map[First,pars,{2}]},
With[{varname=Map[StringReplace[#//TeXForm//ToString,Except[LetterCharacter]->""]&,varslist],varsub=Map[StringJoin["[",ToString[#],"]"]&,varslist]},
With[{ExpReplaceRules=Apply[Rule,{varslist,varsub}//Transpose,1],StringReplaceRules=Apply[Rule,{Map[ToString[#//TeXForm]&,varsub],Map[StringJoin["{",#,"}"]&,varname]}//Transpose,1]},
With[{AnswerTransformRules=Join[StringReplaceRules,TeXRoExprRule]},
GenerateCalculatedQuestion[name,StringReplace[question/.ExpReplaceRules//ToMoodleHTMLString,StringReplaceRules],Sequence@@Apply[Rule,{varname,varslist/.pars//Transpose}//Transpose,1],Sequence@@Map[If[ParametrizedAnswerQ[#],Prepend[#//Rest,StringReplace[First[#]/.ExpReplaceRules/.{E->exp[1],Power->pow,Abs->abs}//TeXForm//ToString,AnswerTransformRules] ],#]&,{R}]]
]
]
]/;Length[varslist]>0
];
(*Tuples for all the possible parameters set*)
GenerateParametrizedQuestion[pars:{__?ListRuleRealQ},R__]:=GenerateParametrizedQuestion[pars//Tuples,R]/;And@@Join[Apply[SameQ,Map[First,pars,{2}],1],Map[RealNumberQ[#//Last]&,pars,{2}]//Flatten];
GenerateParametrizedQuestion::usage="GenerateParametrizedQuestion[list of parameters, name, question, answers, units] uses GenerateCalculatedQuestion in order to produce the calculated question with variables defined by the values of the parameters, question and answers must depend on the parameters. The question is a list with Hold to convert by ToMoodleHTMLString. Each answer is a list {expression, fraction, tolerance}, with expression depending on the parameters and positive tolerance.";


(*Each parameter is attributed to a list*)
GenerateParametrizedNumericalList[pars__?RuleRealListQ,R__]:=GenerateParametrizedNumericalList[Map[RuleRealListToListRule,{pars}]//Tuples,R];
GenerateParametrizedNumericalList[pars:{__?RuleRealListQ},R__]:=GenerateParametrizedNumericalList[Map[RuleRealListToListRule,pars]//Tuples,R];
(*There is only one parameter*)
GenerateParametrizedNumericalList[pars_?ListRuleRealQ,R__]:=GenerateParametrizedNumericalList[{pars}//Transpose,R]/;Apply[SameQ,First/@pars];
(*Various formats of parametrized answers*)
ParametrizedNumericalAnswerQ[{answer_,frac_?RealNumberQ,tolerance_/;tolerance>=0}]:=True;
ParametrizedNumericalAnswerQ[_]:=False;
GenerateParametrizedNumericalList[pars:{__?ListRuleRealQ},name_String/;name!="",question_?ListWithHoldQ,R__/;ParametrizedNumericalAnswerQ[{R}//First]]:=Map[GenerateNumericalQuestion[name,question/.#//ToMoodleHTMLString,Sequence@@ReplaceAll[{R},#]]&,pars]/;Length[Intersection@@Map[First,pars,{2}]]>0;
(*Tuples for all the possible parameters set*)
GenerateParametrizedNumericalList[pars:{__?ListRuleRealQ},R__]:=GenerateParametrizedNumericalList[pars//Tuples,R]/;And@@Join[Apply[SameQ,Map[First,pars,{2}],1],Map[RealNumberQ[#//Last]&,pars,{2}]//Flatten];
GenerateParametrizedNumericalList::usage="GenerateParametrizedNumericalList[list of parameters, name, question, answers, units] uses GenerateNumericalQuestion in order to produce list of questions for each set of the parameters, question and answers may depend on the parameters. The question is a list with Hold to convert by ToMoodleHTMLString. Each answer is a list {expression, fraction, tolerance}.";


PortugueseTrigReplace[L_List]:=Map[PortugueseTrigReplace,L];
PortugueseTrigReplace[s_String]:=StringReplace[s,{"\\sin"->"\\textrm{sen}" ,"\\sinh"->"\\textrm{senh}" ,"\\cos"->"\\textrm{cos}","\\cosh"->"\\textrm{cosh}"}];
PortugueseTrigReplace::usage="PortugueseTrigReplace replaces \\sin and \\sinh to sen and senh.";


(*Definition of division of variants*)
Frac[n_,0]:=n;
Frac[n_,d_]:=n/d;
(*Representation of an expression with integer coefficients*)
ParseIntegerNumericExpr[n_Integer]:=n;
ParseIntegerNumericExpr[n_/;Im[n]===0]:=With[{den=n//Denominator},If[den===1,With[{r=Level[n,{1},Heads->True]},If[Length[r]>0,r,n]],{Frac,n//Numerator//ParseIntegerNumericExpr,den//ParseIntegerNumericExpr}]];
ParseIntegerNumericExpr[n_?NumberQ]:={Plus,n//Re//ParseIntegerNumericExpr,{Times,n//Im//ParseIntegerNumericExpr,I}};
ParseIntegerNumericExpr[n_]:=With[{r=Level[n,{1},Heads->True]},If[Length[r]>0,Prepend[Map[ParseIntegerNumericExpr,r//Rest],First[r]],n]];
(*Recursive restore expression*)
RestoreNumericExpr[{H_Symbol,L__}]:=Check[Apply[H,Map[RestoreNumericExpr,{L}]],1]//Quiet;
RestoreNumericExpr[e_]:=e;


(*Operations with variants*)
MapPower[a:{__Integer},b:{__Integer}]:=Map[Power[#,b]&,DeleteCases[a,0]]//Flatten;
MapTimes[p__List]:=Apply[Times,Tuples[{p}],1];
(*Change base integer*)
BaseIntegerVariants[i_Integer]:={i-1,i,i+1};
IntegerVariants[0]:=BaseIntegerVariants[0];
IntegerVariants[n_Integer]:=DeleteCases[Join[Apply[MapTimes,Apply[MapPower,Map[BaseIntegerVariants,FactorInteger[n],{2}],1]],BaseIntegerVariants[n]]//Union,i_/;Abs[i]>2Abs[n]];


(*Expansion of variants*)
HomogeneousListIntegerQ[{__Integer}]:=True;
HomogeneousListIntegerQ[L:{__List}]:=Map[First,L]//SameQ;
HomogeneousListIntegerQ[e_]:=False;
(*ExpandVariants[L_List]:=L//.{{X__/;!HomogeneousListIntegerQ[{X}//Last],H__?HomogeneousListIntegerQ}:>Map[Join[{X},#]&,{H}//Tuples],{X__/;!HomogeneousListIntegerQ[{X}//Last],H__?HomogeneousListIntegerQ,e__}:>Map[Join[{X},#,{e}]&,{H}//Tuples]}//.{LL__List/;ListQ[{LL}//First//First]}:>Join[LL];*)
ExpandVariants[L_List]:=L//.{X__/;!HomogeneousListIntegerQ[{X}//Last],H__/;HomogeneousListIntegerQ[{H}//First]}:>Map[Join[{X},#]&,Map[If[HomogeneousListIntegerQ[#],#,{#}]&,{H}]//Tuples]//.{LL__List/;ListQ[{LL}//First//First]}:>Join[LL];


(*Main function*)
GenerateSimilarExpression[correct_]:=With[{expr=ParseIntegerNumericExpr[correct/.List->list]},
With[{exprlst=If[ListQ[expr],expr,{Frac,{Times,IntegerVariants[-1],correct},IntegerVariants[-1]}]},
With[{gen=Map[RestoreNumericExpr,{exprlst/.i_Integer:>IntegerVariants[i]}//ExpandVariants]},
With[{res=If[Length[gen]>1,gen,Map[RestoreNumericExpr,Prepend[Map[{Frac,{Times,IntegerVariants[-1],#},IntegerVariants[-1]}&,exprlst//Rest],exprlst//First]//ExpandVariants]]},
ReplaceAll[DeleteCases[res//Simplify,correct]//Union,list->List]
]
]
]
];
(*Recursively applying GenerateSimilarExpression to the generated expressions until target n is reached*)
AddSimExprToList[baselst_List,newlst_List,n_Integer]:=With[{lst=Union[baselst,newlst]},
If[Length[lst]<=n,AddSimExprToList[lst,Union@@Map[GenerateSimilarExpression,newlst],n],lst]
];
(*Generate at least n expressions*)
GenerateSimilarExpression[correct_,n_Integer/;n>0]:=With[{lst=GenerateSimilarExpression[correct]},
If[0<Length[lst]<n,DeleteCases[AddSimExprToList[{correct},lst,n],correct],lst]
];
GenerateSimilarExpression::usage="GenerateWrongAnswers[expression] tries to generate expressions similar to the given one, assuming that initial expression has integer coefficients.";


End[];


Protect[ParseMoodleXML,GenerateMoodleXML,GenerateEssayQuestion,GenerateTrueQuestion,GenerateFalseQuestion,GenerateMultiChoiceQuestion,GenerateNumericalQuestion,GenerateShortQuestion,GenerateRandomValue,GenerateCalculatedQuestion];
Protect[GenerateMultiChoiceList,GenerateSingleChoiceList,GenerateParametrizedQuestion,GenerateParametrizedNumericalList,AddCategoriesToQuestions,RemoveCategoriesFromQuestions];
Protect[QuestionHintList,QuestionOptionList,QuestionAllAnswerList,QuestionAnswerList,QuestionCorrectAnswerList,QuestionIncorrectAnswerList,QuestionWrongAnswerList];
Protect[DefaultClozeFormat,DefaultClozeFormatQuestion,ConvertMultiChoiceToCloze];
Protect[ToMoodleHTMLString,PortugueseTrigReplace,GenerateSimilarExpression];


EndPackage[];
